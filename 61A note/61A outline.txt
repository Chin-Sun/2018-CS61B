1. Functions--basic
2. Control------------
	Print and None;
	Miscellaneous Python Features; 
	Conditional Statement;
	Iteration;
	Return;
	Designing Functions;
3. Higher-Order Functions-------
	Higher-Order Functions: General patterns with assignments and computational process；
	Return a functions as Return Values: Locally Defined function；
	One example;
	Function Composition: compose two or more functions into one expression to achieve them
        Function Currying: multiple-functions--->one single higher-function
	Abstraction: The rule of name function and value -->easily understand;
			f,g,h - Function
			x,y,z - Real number
			n,k,i - Integers
**********************************************************************************
4. Environment Diagram--------
	Multiple Environments: how multiple functions work in one environments;
	Environments for Higher-Order Functions: how it works
        One example↑
	Environments for Nested Definitions: how to draw an Environment Diagram
	Local Names: local function without being nested in the parent of function (no def within def)
	Lambda Expressions: square = lambda x: x*x        vs. def statements
	Self Reference: more clear explaination about the environment diagram
	Decorator: @higher_function
5. Recursion------------------
	Recursional Functions: defination
	Recursion in Environment Diagrams：how it work in environment diagram
	Mutual Recursion: two functions use each other;  
	Recursion and Iteration: how to convert one to another one;  
	Order of Recursive calls: Without return stataement---> return value=None ---> return to the former frame to execute-->(f4-->f3-->f2-->f1-->global)； 
put the base function first + make programmer easier to read for others;  
	One example↑
6. Tree Recursion----------
	Tree Recursion: more than once to call this function within its body.
	One example↑
	Implementating Functions:
************************************************************************************  
7. Sequence & Data Abstraction-----------  
	Lists: digits=[1,2,4]----->digit[0]=1  
	Containers: in; not in;   
	For Sequence: for <name> in <expression>:  
			  <suite>  
	Ranges: range(starting_value, ending_value)---->length is ending_value-starting_value; element = starting_value ~ index[length - 1];  
	List Compresions: [x+1 for x in range(2,n) if n%x==0];  
	Strings: length; sequence; in& not in  
	Data Abstraction: ----rational numbers----rational(n,d)=n/d; numer(x)=n; denom(x)=d;  
	Representing Rational Numbers: change functions;  
	Abstraction Barriers: write your program in a modular way.
	





				
